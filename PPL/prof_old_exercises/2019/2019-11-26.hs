module ES7 where

-- We saw:
-- Functors, to lift a function so that it works on a container/context
-- fmap (+2) (Just 5)
-- :t fmap (+2)
-- Applicative, to do the same with functions with multiple arguments
-- (+) <$> Just 5 <*> Just 2

-- What if we have a function that *returns* a value wrapped in a container/context?
apply42 f x = let s = f x
              in if s > 42 then Just s else Nothing

-- we want to apply a sequence of functions to an initial value,
-- but none of them can return a value lower than 42.
sequence42 x = case apply42 (+12) x of
  Nothing -> Nothing
  Just x1 -> case apply42 (\x -> x-6) x1 of
    Nothing -> Nothing
    Just x2 -> apply42 (*2) x2

-- Try sequence42 42
-- sequence42 30

-- We must combine the information in the context containing the input value
-- with the context generated by the function in the output value.

-- class Monad m where
--   return :: a -> m a
--   (>>=) :: m a -> (a -> m b) -> m b
--   (>>) :: m a -> m b -> m b
--   x >> y = x >>= \_ -> y
--   fail :: String -> m a
--   fail msg = error msg

-- instance Monad Maybe where
--   return x = Just x
--   Nothing >>= f = Nothing
--   Just x >>= f  = f x
--   fail _ = Nothing

sequence42' x = return x
  >>= apply42 (+12)
  >>= apply42 (\x -> x-6)
  >>= apply42 (*2)

-- do notation:
sequence42do x = do
  x1 <- apply42 (+12) x
  x2 <- apply42 (\x -> x-6) x1
  x3 <- apply42 (*2) x2
  return x3

-- this gets translated to
sequence42do' x = apply42 (+12) x >>=
  (\x1 -> apply42 (\x -> x-6) x1 >>=
    (\x2 -> apply42 (*2) x2 >>=
      (\x3 -> return x3)))

sequenceDiscard x = do
  apply42 (+1) x
  x1 <- apply42 (*2) x
  return x1

-- this is the same as
sequenceDiscard' x = apply42 (+1) x >> apply42 (*2) x
  >>= (\x1 -> return x1)

sequenceDiscard'' x = apply42 (+1) x >>=
  (\_ -> apply42 (*2) x >>= (\x1 -> return x1))

-- Let's make a Monad ourselves!
-- The Log Monad
type Log = [String]
newtype Logger a = Logger { unwrap :: (a, Log) }

getContent l = x where (x, _) = unwrap l
getLog l = log where (_, log) = unwrap l

instance (Eq a) => Eq (Logger a) where
  Logger (x, _) == Logger (y, _) = x == y

instance (Show a) => Show (Logger a) where
  show l = show (getContent l)
    ++ "\n\nLog:"
    ++ foldr (\line acc -> "\n\t" ++ line ++ acc)
             ""
             (getLog l)

instance Functor Logger where
  fmap f l = let (x, log) = unwrap l
             in Logger (f x, log)

-- Functor laws:
-- fmap id = id
-- fmap (f . g) = fmap f . fmap g
-- what if we modified the log?

instance Applicative Logger where
  pure x = Logger (x, [])
  Logger (f, lf) <*> Logger (x, lx) =
    Logger (f x, lf ++ lx)

-- (+) <$> Logger (2, ["first operand: 2"]) <*> Logger (3, ["second operand: 3"])

instance Monad Logger where
  return = pure
  Logger (x, log) >>= f = let (y, newLog) = unwrap $ f x
                          in Logger (y, log ++ newLog)

logPlusOne :: (Num a) => a -> Logger a
logPlusOne x = Logger (x+1, ["Add one."])

logMultiplyTwo x = Logger (x*2, ["Multiply by two."])

doOps x = do
  x1 <- logPlusOne x
  logMultiplyTwo x1
  x3 <- logPlusOne x1
  return x3

-- Monadic Laws
-- Left identity: return a >>= f ≡ f a
-- f has the type (a -> m b) so it returns a monad
-- this means that the minimal context to return 
-- is just applying f to a

-- return 42 >>= logPlusOne
-- logPlusOne 42

-- Right identity: m >>= return ≡ m
-- When we feed monadic values to functions by using >>=, 
-- those functions take normal values and return monadic ones. 
-- return is also one such function, if you consider its type.

-- Logger (1,["barnibalbi"]) >>= return

-- Associativity:  (m >>= f) >>= g ≡ m >>= (\x -> f x >>= g)

doOps' x = logPlusOne x >>=
  (\x1 -> logMultiplyTwo x1 >>=
    (\x2 -> logPlusOne x2 >>=
      (\x3 -> return x3)))
-- doOps 3 is the same as
-- doOps' 3


-- Let us take our binary trees again
data BTree a = BEmpty | BNode a (BTree a) (BTree a) deriving Eq

instance (Show a) => Show (BTree a) where
  show BEmpty = "BEmpty"
  show (BNode x BEmpty BEmpty) = "BNode " ++ show x
  show (BNode x l r) = "BNode "++ show x ++ " (" ++ show l ++ ") (" ++ show r ++ ")"

bleaf x = BNode x BEmpty BEmpty

putLog :: String -> Logger ()
putLog msg = Logger ((), [msg])

bleafM x = do
  putLog $ "Create leaf " ++ show x
  return $ bleaf x

treeReplaceM :: (Show a) => (BTree a) -> (a -> Bool) -> a
  -> Logger (BTree a)
treeReplaceM BEmpty _ _ = return BEmpty
treeReplaceM (BNode x l r) p y = do
  newL <- treeReplaceM l p y
  newR <- treeReplaceM r p y
  if p x
  then do
    putLog $ "Replaced " ++ show x ++ " with " ++ show y
    return $ BNode y newL newR
  else do
    return $ BNode x newL newR

-- This is the same as
-- treeReplaceM (BNode x l r) p y =
--   treeReplaceM l p y >>=
--   (\newL -> treeReplaceM r p y >>=
--             (\newR -> if p x
--               then do
--                 putLog $ "Replaced " ++ show x ++ " with " ++ show y
--                 return $ BNode y newL newR
--               else
--                 return $ BNode x newL newR))
